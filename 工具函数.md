# 0 - n 的随机数
```javascript
    Math.floor(Math.random() * (n + 1));
```
# Max - Min 的随机数
```javascript
// 一、min ≤ r ≤ max
function RandomNumBoth(Min,Max){
    var Range = Max - Min;
    var Rand = Math.random();
    var num = Min + Math.round(Rand * Range); //四舍五入
    return num;
}

// 二、min ≤ r < max
function RandomNum(Min, Max) {
    var Range = Max - Min;
    var Rand = Math.random();
    var num = Min + Math.floor(Rand * Range); //舍去
    return num;
}

// 三、min < r ≤ max
function RandomNum(Min, Max) {
    var Range = Max - Min;
    var Rand = Math.random();
    if(Math.round(Rand * Range)==0){       
        return Min + 1;
    }
    var num = Min + Math.round(Rand * Range);
    return num;
}

// 四、min < r < max 
function RandomNum(Min, Max) {
    var Range = Max - Min;
    var Rand = Math.random();
    if( Math.round(Rand * Range)==0 ){
        return Min + 1;
    } else if(Math.round(Rand * Max)==Max){
        index++;
        return Max - 1;
    }else{
        var num = Min + Math.round(Rand * Range) - 1;
        return num;
    }
 }
```

# 数组打乱排序
```javascript
function shuffle(array) {
    var _array = array.concat();
    for (var i = _array.length; i--; ) {
        // 产生 0 - i 的随机数
        var j = Math.floor(Math.random() * (i + 1));
        var temp = _array[i];
        _array[i] = _array[j];
        _array[j] = temp;
    }
    return _array;
}
```
# 深拷贝 - extend 的实现
```javascript
// 深拷贝有bug
var extend = (function() {
	var isObjFunc = function(name) {
			var toString = Object.prototype.toString
			return function() {
				return toString.call(arguments[0]) === '[object ' + name + ']'
			}
		}
	var isObject = isObjFunc('Object'),
		isArray = isObjFunc('Array'),
		isBoolean = isObjFunc('Boolean');
 	return function extend() {
			var index = 0,
				isDeep = false,
				obj, copy, destination, source, i
			if (isBoolean(arguments[0])) {
				index = 1;
				 isDeep = arguments[0]
			}
			for (i = arguments.length - 1; i > index; i--) {
				destination = arguments[i - 1]; source = arguments[i]
				if (isObject(source) || isArray(source)) {
					console.log(source);
					for (var property in source) {
						obj = source[property];
						if (isDeep && (isObject(obj) || isArray(obj))) {
							copy = isObject(obj) ? {} : [];
							var extended = extend(isDeep, copy, obj);
							 destination[property] = extended
						} else {
							destination[property] = source[property]
						}
					}
				} else {
					destination = source
				}
			}
			return destination
		}
})()


作者：文兴
链接：https://www.jianshu.com/p/04b1d88dabf2
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


// 可以
void function(global){
    var extend,
        _extend,
        _isObject;

    _isObject = function(o){
        return Object.prototype.toString.call(o) === '[object Object]';
    }

    _extend = function self(destination, source) {
        var property;
        for (property in destination) {
            if (destination.hasOwnProperty(property)) {

                // 若destination[property]和sourc[property]都是对象，则递归
                if (_isObject(destination[property]) && _isObject(source[property])) {
                    self(destination[property], source[property]);
                };

                // 若sourc[property]已存在，则跳过
                if (source.hasOwnProperty(property)) {
                    continue;
                } else {
                    source[property] = destination[property];
                }
            }
        }
    }

    extend = function(){
        var arr = arguments,
            result = {},
            i;

        if (!arr.length) return {};

        for (i = arr.length - 1; i >= 0; i--) {
            if (_isObject(arr[i])) {
                _extend(arr[i], result);
            };
        }

        arr[0] = result;
        return result;
    }

    global.extend = extend;
}(window)
```

# 深拷贝
```javascript
function cloneObject (obj) {
    var newObj = {}
    //如果不是引用类型，直接返回
    if ( obj instanceof Object ) {
      return obj
    }
    //如果是引用类型，遍历属性
    else{
         for (var attr in obj) {
         //如果某个属性还是引用类型，递归调用
          newObj[attr] = cloneObject(obj[attr])
        }
    }
   
    return newObj
  }
```

# 浅拷贝
```javascript
var extend = function(destination,source) {
    for(var property in source) {
        destination[property] = source[property]
    }
    return destination
}
```

# 移动端遮罩穿透
```javascript
/**
  * ModalHelper helpers resolve the modal scrolling issue on mobile devices
  * https://github.com/twbs/bootstrap/issues/15852
  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element
  */
var ModalHelper = (function(bodyCls) {
  var scrollTop;
  return {
    afterOpen: function() {
      scrollTop = document.scrollingElement.scrollTop;
      document.body.classList.add(bodyCls);
      document.body.style.top = -scrollTop + 'px';
    },
    beforeClose: function() {
      document.body.classList.remove(bodyCls);
      // scrollTop lost after set position:fixed, restore it back.
      document.scrollingElement.scrollTop = scrollTop;
    }
  };
})('modal-open');
```

# vue中解析template用到的一些正则方法
```javascript

const ncname = '[a-zA-Z_][\\w\\-\\.]*'; 
const singleAttrIdentifier = /([^\s"'<>/=]+)/ 
const singleAttrAssign = /(?:=)/ 
const singleAttrValues = [ /"([^"]*)"+/.source, /'([^']*)'+/.source, /([^\s"'=<>`]+)/.source ] 
const attribute = new RegExp( '^\\s*' + singleAttrIdentifier.source + '(?:\\s*(' + singleAttrAssign.source + ')' + '\\s*(?:' + singleAttrValues.join('|') + '))?' ) 
const qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')' 
const startTagOpen = new RegExp('^<' + qnameCapture) 
const startTagClose = /^\s*(\/?)>/ 
const endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>') 
const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g 
const forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/

https://juejin.im
掘金 — 一个帮助开发者成长的社区
```

# 获取某月最后一天
```javascript
new Date( 2018, 03, 0 ) // 序列化后的结果  "2018-03-31 00:00:00"
new Date( 2018, 02, 0 ) // 序列化后的结果  "2018-02-28 00:00:00"  自动计算是否是闰月
```

# 获取当前月的下个月的第一天
```javascript
new Date(2018, 03, 1) // 序列化后的结果  "2018-04-01 00:00:00"
```

# 获取当前月的第一天

> 有用吗？ 每个月不都一号么。。 

```javascript
new Date('2018/03/1') // 序列化后的结果  "2018-03-01 00:00:00"
```

# 循环一段数字N次
```javascript
function repeat( str, num ){
	return new Array( num + 1 ).join( str );
}

// 举个栗子
repeat( '123', 3 )
"123123123"

// 将数组的间隔转换成字符串  
```

# 零宽断言
```javascript
// 测试 谷歌支持 火狐IE不支持  2018-03-14 之后的版本就不清楚啦
'My name is: Jerry . My age is: 12 . : :666 .'.match(/(?<=:\s?)([^\s:]+)/g)

// 输出 (3) ["Jerry", "12", "666"]
```

# 数组去重 并统计每项有多少重复值
```javascript
// 数组去重并统计每一项有几个
var arr = ["a","b","c","c","ab","d","ab","d","c"],
	newArr = [],
	obj = {};
for ( var i = 0, l = arr.length; i < l; i++ ){
    if( newArr.indexOf( arr ) <= -1 ){
        newArr.push( arr );
        obj[arr] = 1
    }else {
        obj[arr] = obj[arr] + 1;
    }    
}
```

# 加减乘除避免失真
```javascript
var work = {
	
	/**
	 * 解决加法失真
	 * @param {Number} 两个数字
	 * work.accAdd(1.1, 2)
	 * */
	accAdd: function (arg1, arg2) {
		var r1, r2, m;
		try {
			r1 = arg1.toString().split(".")[1].length
		} catch (e) {
			r1 = 0
		}
		try {
			r2 = arg2.toString().split(".")[1].length
		} catch (e) {
			r2 = 0
		}
		m = Math.pow(10, Math.max(r1, r2));
		//console.log(m)
		return (arg1 * m + arg2 * m) / m;
	},
	/**
	 * 解决减法失真
	 * @param {Number} 两个数字
	 * work.accSub(1.1, 2)
	 * */
	accSub: function (arg1, arg2) {
		var r1, r2, m, n;
		try {
			r1 = arg1.toString().split(".")[1].length
		} catch (e) {
			r1 = 0
		}
		try {
			r2 = arg2.toString().split(".")[1].length
		} catch (e) {
			r2 = 0
		}
		m = Math.pow(10, Math.max(r1, r2));
		//last modify by deeka
		//动态控制精度长度
		n = (r1 >= r2) ? r1 : r2;
		return ((arg1 * m - arg2 * m) / m).toFixed(n);
	},
	/**
	 * 解决乘法失真
	 * @param {Number} 两个数字
	 * work.accMul(1.1, 2)
	 * */
	accMul: function (arg1, arg2) {
		var m = 0,
			s1 = arg1.toString(),
			s2 = arg2.toString();
		try {
			m += s1.split(".")[1].length
		} catch (e) {}
		try {
			m += s2.split(".")[1].length
		} catch (e) {}
		return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m)
	},
	/**
	 * 解决除法失真
	 * @param {Number} 两个数字
	 * work.accDiv(1.1, 2)
	 * */
	accDiv: function (arg1, arg2) {
		var t1 = 0,
			t2 = 0,
			r1, r2;
		try {
			t1 = arg1.toString().split(".")[1].length
		} catch (e) {}
		try {
			t2 = arg2.toString().split(".")[1].length
		} catch (e) {}
		with(Math) {
			r1 = Number(arg1.toString().replace(".", ""));
			r2 = Number(arg2.toString().replace(".", ""));
			return (r1 / r2) * pow(10, t2 - t1);
		}
	}
}	
```

# 多层数据的查找
> [面试题：给你个id，去拿到name，多叉树遍历](https://segmentfault.com/a/1190000014381365)

```javascript
var cityData = [
      {
        id: 1,
        name: '广东省',
        children: [
          {
            id: 11,
            name: '深圳',
            children: [
              {
                id: 111,
                name: '宝安',
                children: [
                  {
                    id: 1111,
                    name: '西乡',
                    children:[
                      {
                        id: 11111,
                        name: '坪洲',
                        children:[]
                      },
                      {
                        id: 11112,
                        name: '灵芝',
                        children:[]
                      }
                    ]
                  },
                  {
                    id: 1112,
                    name: '南山',
                    children:[
                      {
                        id: 11121,
                        name: '科技园',
                        children:[]
                      }
                    ]
                  }
                ]
              },
              {
                id: 112,
                name: '福田',
                children: []
              }
            ]
          },
          {
            id: 12,
            name: '广州',
            children: [
              {
                id: 122,
                name: '白云区',
                children: [
                  {
                    id: 1222,
                    name: '白云区',
                    children: []
                  }
                ]
              },
              {
                id: 122,
                name: '珠海区',
                children: []
              }
            ]
          }
        ]
      },
      {
        id: 2,
        name: '湖南省',
        children: []
      }
    ];
```

**递归方法**
```javascript

let result = ''

// 递归实现
const recursion = (cityData, id) => {
  // cityData数据为空的时候直接返回
  if (!cityData || !cityData.length) return;
  // 常规循环cityData
  for (let i = 0, len = cityData.length; i < len; i++) {
    const childs = cityData[i].children;
    
    // 如果匹配到id的话，就是我们要的结果
    if (cityData[i].id === id) {
      result = cityData[i].name
    }
    // 如果还有子节点，执行递归
    if(childs && childs.length > 0){
      recursion(childs, id);
    }
  }
  return result
};

const r = recursion(cityData, 11112);
console.log(r) // 灵芝
```

**广度优先实现**
```javascript
let result = ''

const range = (cityData, id) => {
  if (!cityData || !cityData.length) return;
  // 定义一个数据栈
  let stack = [];

  let item = null;

  //先将第一层节点放入栈
  for (var i = 0, len = cityData.length; i < len; i++) {
    stack.push(cityData[i]);
  }

  while (stack.length) {
    // 将数据栈的第一个取出来
    item = stack.shift();
    // 如果符合就赋值给result
    if (item.id === id) {
      result = item.name
    }
    //如果该节点有子节点，继续添加进入栈底
    if (item.children && item.children.length) {
      stack = stack.concat(item.children);
    }
  }
  return result
};

let r1 = range(cityData, 11112);

console.log(r1) // 灵芝
```

**深度优先实现**
```javascript
let result = ''

const deep = (cityData, id) => {
  // 没有数据直接返回
  if (!cityData || !cityData.length) return;
  // 先定义一个数据栈
  let stack = []
  let item = null

  //先将第一层节点放入数据栈
  for (var i = 0, len = cityData.length; i < len; i++) {
    stack.push(cityData[i])
  }
  // 循环
  while (stack.length) {
    item = stack.shift()
    if (item.id === id) {
      result = item.name
    }
    //如果该节点有子节点，继续添加进入栈顶
    if (item.children && item.children.length) {
      // 注意这里调换了顺序
      stack = item.children.concat(stack);
    }
  }
  return result
};

let r3 = deep(cityData, 11112)
console.log(r3) // 灵芝
```

**正则方式实现**
```javascript

const regular = (cityData, id) => {
  // 没有数据直接返回
  if (!cityData || !cityData.length) return;
  // 数据转成字符串
  let cityStr = JSON.stringify(cityData)
  // 定义正则
  let reg = new RegExp(`"id":${id},"name":"([^\\x00-\\xff]+)",`)
  // 取到正则的子字符串并返回
  return (cityStr.match(reg))[1]
}

let r4 = regular(cityData, 11112);

console.log(r4) // 灵芝

```

** 图片canvas压缩 转blob对象 **
```javascript
utils = {
	// 压缩比率
    quality: 0.5,
    // 执行压缩图片
    photoCompress: function (file, w, objDiv){
        var ready = new FileReader();
        /*开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.*/
        ready.readAsDataURL(file);
        ready.onload = function(){
            var re = this.result;
            utils.canvasDataURL(re, w, objDiv)
        }
    },
    // 压缩图片的详细
    canvasDataURL: function (path, obj, callback){
        var img = new Image();
        img.src = path;
        img.onload = function(){
            var that = this;
            // 默认按比例压缩
            var w = that.width,
                h = that.height,
                scale = w / h;
            w = obj.width || w;
            h = obj.height || (w / scale);
            var quality = 0.7;  // 默认图片质量为0.7
            //生成canvas
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            // 创建属性节点
            var anw = document.createAttribute("width");
            anw.nodeValue = w;
            var anh = document.createAttribute("height");
            anh.nodeValue = h;
            canvas.setAttributeNode(anw);
            canvas.setAttributeNode(anh);
            ctx.drawImage(that, 0, 0, w, h);
            // 图像质量
            if(obj.quality && obj.quality <= 1 && obj.quality > 0){
                quality = obj.quality;
            }
            // quality值越小，所绘制出的图像越模糊
            var base64 = canvas.toDataURL('image/jpeg', quality);
            // 回调函数返回base64的值
            callback(base64);
        }
    },
    /**
        * 将以base64的图片url数据转换为Blob
        * @param urlData
        *            用url方式表示的base64图片数据
        */
    convertBase64UrlToBlob: function (urlData){
        var arr = urlData.split(','), mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
        while(n--){
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {type:mime});
    }
}
```

# 格式化日期
> 垃圾代码

```javascript
// 序列化日期
/**
 * @param 获取当前日期的时间戳返回对应日期 
 * @param {Number | String}
 * @param {Number} 1 => "2017-09-08 09:25:21"
 * @param {Number} 2 => "2017-09-08"
 * @prarm {String} year  获取当前年份 
 * @prarm {String} month  获取当前月份 
 * @prarm {String} day  获取当前几号 
 * */
export const formatDate =  (option) => {
  option = option || {};
  option.time = option.time || '/';
  option.type = option.type || "";
  // 为什么转成时间戳 因为ios - 的时间格式会报错
  option.time = Date.parse( option.time );
  if( isNaN( option.time ) ){
    return '/'
  };
  let date = new Date(option.time),
    year = date.getFullYear(),
    month = date.getMonth() + 1,
    day = date.getDate(),
    hour = date.getHours(),
    minute = date.getMinutes(),
    second = date.getSeconds();
  month < 10 ? month = '0' + month : month = month.toString();
  day < 10 ? day = '0' + day : day = day.toString();
  hour < 10 ? hour = '0' + hour : hour = hour.toString();
  minute < 10 ? minute = '0' + minute : minute = minute.toString();
  second < 10 ? second = '0' + second : second = second.toString();
  switch (option.type) {
    case 1:
      var time = year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;
      return time;
      break;
    case 2:
      return year + "-" + month + "-" + day;
      break;
    case 'year':
      return year
      break;
    case 'month':
      return month
      break;
    case 'day':
      return day
      break;
    default:
      return ''
      break;
  }
}
```

# echarts 半环形进度条
>  [例子地址](http://gallery.echartsjs.com/editor.html?c=xrJzQ35eVM) 复制上去配置项


```javascript
option = {
    tooltip: {
        formatter: "{a} <br/>{b} : {c}"
    },
    series: [{
        //类型
        type: 'gauge',
        //半径
        radius: 180,
        //起始角度。圆心 正右手侧为0度，正上方为90度，正左手侧为180度。
        startAngle: 180,
        //结束角度。
        endAngle: 0,
        center: ['50%', '50%'],
        //仪表盘轴线相关配置。
        axisLine: {
            show: true,
            // 属性lineStyle控制线条样式
            lineStyle: {
                width: 40,
                color: [
                    [0.6, '#3ebfff'],
                    [1, '#f5f5f5']
                ]
            }
        },
        //分隔线样式。
        splitLine: {
            show: false,
        },
        //刻度样式。
        axisTick: {
            show: false,
        },
        //刻度标签。
        axisLabel: {
            show: true,
            distance: -20,
            lineHeight: 100,
            color: '#000',
            formatter: function( params ){
                if( params == 0  ){
                    return '\n\n\n\v\v' + 0
                }else if( params == 100 ){
                    return '\n\n\n\v' + 100
                }else{
                    return ''
                }
            }
        },
        //仪表盘指针。
        pointer: {
            //这个show属性好像有问题，因为在这次开发中，需要去掉指正，我设置false的时候，还是显示指针，估计是BUG吧，我用的echarts-3.2.3；希望改进。最终，我把width属性设置为0，成功搞定！
            show: false,
            //指针长度
            length: '90%',
            width: 0,
        },
        //仪表盘标题。
        title: {
            show: true,
            offsetCenter: [0, '-25%'], // x, y，单位px
            textStyle: {
                color: '#000',
                fontSize: 12
            }
        },
        //仪表盘详情，用于显示数据。
        detail: {
            show: false,
            offsetCenter: [0, '-10%'],
            formatter: '{value}',
            textStyle: {
                fontSize: 12
            }
        },
        data: [{
            value: '',
            name: '60%',
        }]
    }]
};
```

# 数组去重
```javascript
Array.prototype.unique = function () {
  const newArray = [];
  let isRepeat;
  for (let i = 0; i < this.length; i++) {
    isRepeat = false;
    for (let j = 0; j < newArray.length; j++) {
      if (this[i] === newArray[j]) {
        isRepeat = true;
        break;
      }
    }
    if (!isRepeat) {
      newArray.push(this[i]);
    }
  }
  return newArray;
}

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
```javascript
Array.prototype.unique = function () {
  const newArray = [];
  let isRepeat;
  for (let i = 0; i < this.length; i++) {
    isRepeat = false;
    for (let j = i + 1; j < this.length; j++) {
      if (this[i] === this[j]) {
        isRepeat = true;
        break;
      }
    }
    if (!isRepeat) {
      newArray.push(this[i]);
    }
  }
  return newArray;
}

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
```javascript
Array.prototype.unique = function () {
  const newArray = [];
  
  for (let i = 0; i < this.length; i++) {
    for (let j = i + 1; j < this.length; j++) {
      if (this[i] === this[j]) {
        j = ++i;
      }
    }
    newArray.push(this[i]);
  }
  return newArray;
}

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
- 10万个随机数的时间
```javascript
test1: 3688.440185546875ms
test2: 4641.60498046875ms
test3: 17684.365966796875ms
```
- indexOf
```javascript

// 利用Array.prototype.filter()过滤功能
// Array.prototype.indexOf()返回的是第一个索引值
// 只将数组中元素第一次出现的返回
// 之后出现的将被过滤掉

Array.prototype.unique = function () {
  return this.filter((item, index) => {
    return this.indexOf(item) === index;
  })
}

let arr = [1, 2, 3, 22, 233, 22, 2, 233, 'a', 3, 'b', 'a'];
Array.prototype.unique = function () {
  const newArray = [];
  this.forEach(item => {
    if (newArray.indexOf(item) === -1) {
      newArray.push(item);
    }
  });
  return newArray;
}

// 耗时
test1: 4887.201904296875ms
test2: 3766.324951171875ms

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
```javascript
Array.prototype.unique = function () {
  const newArray = [];
  this.sort();
  for (let i = 0; i < this.length; i++) {
    if (this[i] !== this[i + 1]) {
      newArray.push(this[i]);
    }
  }
  return newArray;
}

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Array.prototype.unique = function () {
  const newArray = [];
  this.sort();
  for (let i = 0; i < this.length; i++) {
    if (this[i] !== newArray[newArray.length - 1]) {
      newArray.push(this[i]);
    }
  }
  return newArray;
}

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

test1: 121.6259765625ms
test2: 123.02197265625ms
```

```javascript
Array.prototype.unique = function () {
  const newArray = [];
  this.forEach(item => {
    if (!newArray.includes(item)) {
      newArray.push(item);
    }
  });
  return newArray;
}

test: 4123.377197265625ms

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
```javascript
Array.prototype.unique = function () {
  return this.sort().reduce((init, current) => {
    if(init.length === 0 || init[init.length - 1] !== current){
      init.push(current);
    }
    return init;
  }, []);
}
test: 180.401123046875ms

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
```javascript
Array.prototype.unique = function () {
  const newArray = [];
  const tmp = new Map();
  for(let i = 0; i < this.length; i++){
        if(!tmp.get(this[i])){
            tmp.set(this[i], 1);
            newArray.push(this[i]);
        }
    }
    return newArray;
}

Array.prototype.unique = function () {
  const tmp = new Map();
  return this.filter(item => {
    return !tmp.has(item) && tmp.set(item, 1);
  })
}

// 综合考虑 map最优
test1: 27.89697265625ms
test2: 21.945068359375ms

作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
作者：棕小渐
链接：https://juejin.im/post/5b0284ac51882542ad774c45
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

# 全屏化某个DOM
```javascript
export default {
  data() {
    return {
      isFull: false
    };
  },
  mounted() {
    this.addListenWindow();
  },
  beforeDestroy() {
    this.removeListenWindow();
  },
  methods: {
    toggleFullScreen($el = document.querySelector("body")) {
      $el && this.fullScreen($el);
    },
    // 以下是全屏的逻辑
    fullScreen(el) {
      // 进入全屏  退出全屏
      if (window.navigator.userAgent.indexOf(".NET ") > -1) {
        if (
          window.outerHeight === window.screen.height &&
          window.outerWidth === window.screen.width
        ) {
          this.escFullScreen(el);
        } else {
          this.toFullScreen(el);
        }
      } else {
        !this.isFullScreen() ? this.toFullScreen(el) : this.escFullScreen(el);
      }
    },
    // 进入全屏
    toFullScreen(el) {
      (el.requestFullscreen && el.requestFullscreen()) ||
        (el.mozRequestFullScreen && el.mozRequestFullScreen()) ||
        (el.webkitRequestFullscreen && el.webkitRequestFullscreen()) ||
        (el.msRequestFullscreen && el.msRequestFullscreen());
      this.isFull = true;
    },
    // 退出全屏
    escFullScreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
      this.isFull = false;
    },
    // 判断是否进入全屏
    isFullScreen() {
      // 火狐升级导致判断失效了 只用window去判断 谷歌 68版本以上也会有这个问题
      // window.fullScreen
      if (navigator.userAgent.indexOf("Firefox") >= 0) {
        return window.fullScreen;
      } else {
        return (
          window.fullScreen ||
          document.webkitIsFullScreen ||
          document.msFullscreenEnabled
        );
      }
    },
    // 获取chrome版本号
    getChromeVerson() {
      let userAgent = navigator.userAgent;
      let strStart = userAgent.indexOf("Chrome");
      let strStop = userAgent.indexOf(" Safari");
      let temp = userAgent.substring(strStart, strStop);
      let arr = temp.match(/\d+/);
      let version = arr[0] ? arr[0] : -1;
      return version;
    },
    addListenWindow() {
      // window.addEventListener("resize", this.toggleChange)
      document.addEventListener("fullscreenchange", this.toggleChange);
      document.addEventListener("webkitfullscreenchange", this.toggleChange);
      document.addEventListener("mozfullscreenchange", this.toggleChange);
      document.addEventListener("MSFullscreenChange", this.toggleChange);
    },
    removeListenWindow() {
      // window.removeEventListener("resize", this.toggleChange)
      document.removeEventListener("fullscreenchange", this.toggleChange);
      document.removeEventListener("webkitfullscreenchange", this.toggleChange);
      document.removeEventListener("mozfullscreenchange", this.toggleChange);
      document.removeEventListener("MSFullscreenChange", this.toggleChange);
    },
    toggleChange() {
      clearTimeout(this.reseizeTimeId);
      // 避免多次触发
      this.reseizeTimeId = setTimeout(() => {
        if (window.navigator.userAgent.indexOf(".NET ") > -1) {
          if (
            window.outerHeight === window.screen.height &&
            window.outerWidth === window.screen.width
          ) {
            this.isFull = true;
          } else {
            this.isFull = false;
          }
        } else {
          !this.isFullScreen() && (this.isFull = false);
        }
      }, 200);
    }
  }
};

```

# 格式化日期
```javascript
/*@param date 时间戳*/
/*@param format 时间格式*/
function dateFormat(date,format){
    if(!format || typeof format !== 'string'){
      console.error('format is undefiend or type is Error');
      return '';
    }

    date = date instanceof Date? date : (typeof date === 'number'|| typeof date === 'string')? new Date(date): new Date();

    //解析
    var formatReg = {
      'y+': date.getFullYear(),
      'M+': date.getMonth()+1,
      'd+': date.getDate(),
      'h+': date.getHours(),
      'm+': date.getMinutes(),
      's+': date.getSeconds()
    }
    for(var reg in formatReg){
      if(new RegExp(reg).test(format)){
            var match = RegExp.lastMatch;
            format = format.replace(match, formatReg[reg]< 10 ? '0'+formatReg[reg]: formatReg[reg].toString() );
      }
    }
    return format;
}

dateFormat(new Date().getTime(),'yyyy-MM-dd hh:mm:ss') 
dateFormat(new Date().getTime(),'MM-dd-yy hh:mm:ss') 
...
```

# 获取URL 域名 + 端口
```javascript
export const getBaseUrl = url => {
    var reg = /^((\w+):\/\/([^/:]*)(?::(\d+))?)(.*)/
    reg.exec(url)
    return RegExp.$1
}
```

# bytes转其他单位
```javascript
export const bytesToSize = bytes => {
    if (bytes === 0) return '0 B'
    let k = 1000 // or 1024
    let sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    let i = Math.floor(Math.log(bytes) / Math.log(k))
    return (bytes / Math.pow(k, i)).toPrecision(3) + ' ' + sizes[i]
}
```

# 数组打乱
```javascript
export const randomArr = arr => {
    function randomsort () {
        return Math.random() > 0.5 ? -1 : 1
        // 用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1
    }
    let newArr = arr.sort(randomsort)
    return newArr
}
```

# trigger 实现
```javascript
export const trigger = (el, event) => {
    if (document.all) {
        el.event()
    } else {
        const evt = document.createEvent('Events') // 还有onchange则是HtmlEvents
        evt.initEvent(event, true, true)
        el.dispatchEvent(evt)
    }
}
```

# 下载传入的文件流
```javascript
/**
 * 下载传入的文件流
 * @param { Blob } blob 文件流
 * @param { String } file_name 生成的文件名称 例如 xxx.jpg xxx.txt
 */
export const download_blob = (blob, file_name) => {
    return new Promise((resolve, reject) => {
        try {
            const BLOB = new Blob([blob])
            if ('download' in document.createElement('a')) {
                // 非IE下载
                const elink = document.createElement('a')
                elink.download = file_name
                elink.style.display = 'none'
                elink.href = URL.createObjectURL(BLOB)
                document.body.appendChild(elink)
                elink.click()
                // trigger 不触发下载 trigger( elink, 'click' )
                // 删除引用 释放URL 对象
                URL.revokeObjectURL(elink.href)
                document.body.removeChild(elink)
                // IE10+下载
            } else {
                navigator.msSaveBlob(BLOB, file_name)
            }
            resolve({
                status: 'success',
                content: ''
            })
        } catch (error) {
            reject(error)
        }
    })
}
```

# dataURLtoBlob
```javascript
export const dataURLtoBlob = dataurl => {
    let arr = dataurl.split(',')
    let mime = arr[0].match(/:(.*?);/)[1]
    let bstr = atob(arr[1])
    let n = bstr.length
    let u8arr = new Uint8Array(n)
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n)
    }
    return new Blob([u8arr], { type: mime })
}
```

# 时间戳转多少时间
```javascript
/**
 * 时间戳转多少时间
 * @param {Date} 日期时间戳
 */
export const time2Long = date => {
    // 传入时间戳
    if (isNaN(date)) {
        return '/'
    }
    // 1 - 1000 毫秒
    if (date >= 1 && date < 1000) {
        return `${date} 毫秒`
        // 1-59s  1000 - 59999
    } else if (date >= 1000 && date < 60000) {
        return `${Math.round(date / 1000)} 秒`
        // 1-59.99分 1*60s*1000  59.99*60*1000 3599400  3600000
    } else if (date >= 60000 && date < 3600000) {
        return `${Math.round(date / 60000)} 分钟`
        // 24小时 一小时3600000毫秒 86400000
    } else if (date >= 3600000 && date < 86400000) {
        return `${Math.round(date / 3600000)} 小时`
    } else if (date >= 86400000) {
        return `${Math.round(date / 86400000)} 天`
    }
}
```

# 数组上移下移
```javascript
{
	moveTop(index) {
      const cur = this.tableData.rows[index];
      cur && this.swapItems(index, index - 1);
    },
    moveBottom(index) {
      const cur = this.tableData.rows[index];
      cur && this.swapItems(index, index + 1);
    },
    swapItems(index1, index2) {
      this.tableData.rows[index1] = this.tableData.rows.splice(
        index2,
        1,
        this.tableData.rows[index1]
      )[0];
    },
}
```

# 数组分组
```javascript
// 比如三个一组
for (let i = 0; i < length; i += 3) {
          newArr.push(arr.slice(i, i + 3));
        }
```

# 百度地图和浏览器定位的封装 
```javascript
// 百度地图右键点击事件是 `rightclick`
import BMap from "BMap";

export default {
  methods: {
    // 将获取的位置解析为百度API
    translatePoint(x, y) {
      return new Promise((resolve, reject) => {
        const point = new BMap.Point(x, y);
        const convertor = new BMap.Convertor();
        let pointArr = [];
        pointArr.push(point);
        convertor.translate(pointArr, 1, 5, data => {
          if (data.status === 0) {
            resolve(data);
          } else {
            reject(new Error("坐标转换失败"));
          }
        });
      });
    },
    // 封装获取位置API方法
    promiseGeo() {
      return new Promise((resolve, reject) => {
        window.navigator.geolocation.getCurrentPosition(
          data => {
            data.coords && resolve(data);
          },
          err => {
            reject(err);
          },
          { timeout: 2000 }
        );
      });
    },
    // 坐标解析成地址
    position2Address(position) {
      return new Promise((resolve, reject) => {
        const myGeo = new BMap.Geocoder();
        myGeo.getLocation(position, rs => {
          var addComp = rs.addressComponents;
          if (addComp) {
            resolve(addComp.province);
          } else {
            reject(new Error());
          }
        });
      });
    },
    // 地址解析成坐标
    address2Position(address) {
      return new Promise((resolve, reject) => {
        const myGeo = new BMap.Geocoder();
        myGeo.getPoint(address, point => {
          point ? resolve(point) : reject(new Error("您的位置没有解析到结果"));
        });
      });
    },
    // 根据用户信息所在的省份设置默认展示的省份
    setPositionByAddress(address) {
      this.address2Position(address).then(data => {
        this.map.setCenter(data);
      });
    },
    createContextMenu(menuArr = []) {
      const menu = new BMap.ContextMenu();
      menuArr.forEach(v => {
        menu.addItem(new BMap.MenuItem(v.name, v.callback, 100));
      });
      this.map.addContextMenu(menu);
    }
  }
};

```

# 百度地图画块逻辑
```javascript
{
	/**
     *
     * 添加地块的逻辑
     */
    // 弹窗点击确认后 获取弹窗中的数据
    getPolygonData(data) {
      this.mapStatus = "edit";
      this.curPointArr = [];
      // 先实例化一个区域范围
      this.createPolygon(data);
      // 监听地图点击事件 给这个范围加点 圈选开始 开始编辑  添加这些点
      this.map.addEventListener("click", this.updatePolygonPoint);
    },
    //
    updatePolygonPoint(event) {
      // 如果点的是拖动的点 不加
      if (event.domEvent.target.className === "BMap_vectex BMap_vectex_node") {
        return;
      }
      this.curPointArr = this.curPolygon.getPath();
      // 每次点击改变这个实例化的
      this.curPointArr.push(event.point);
      this.curPolygon.setPath(this.getPolygonPath());
      this.curPolygon.enableEditing();
    },
    // 创建点
    createPolygon(data) {
      const polygon = new BMap.Polygon(this.getPolygonPath(), {
        strokeColor: data.color,
        strokeWeight: 1,
        strokeOpacity: 1,
        fillColor: data.color,
        fillOpacity: 0.4
      });
      polygon.htData = data;
      this.map.addOverlay(polygon);
      polygon.enableEditing();
      this.addPolygonEvent(polygon);
      this.curPolygon = polygon;
    },
    // 将点解析为可以画圈的点
    getPolygonPath() {
      return this.curPointArr.map(v => {
        const { lng, lat } = v;
        return new BMap.Point(lng, lat);
      });
    }
}
```

# 省市对应坐标
```javascript
export default {
  北京市: [116.4551, 40.2539],
  天津市: [117.4219, 39.4189],
  河北省: [114.4995, 38.1006],
  山西省: [112.3352, 37.9413],
  内蒙古自治区: [111.4124, 40.4901],
  辽宁省: [123.1238, 42.1216],
  吉林省: [125.8154, 44.2584],
  黑龙江省: [127.9688, 45.368],
  上海市: [121.4648, 31.2891],
  江苏省: [118.8062, 31.9208],
  浙江省: [119.5313, 29.8773],
  安徽省: [117.29, 32.0581],
  福建省: [119.4543, 25.9222],
  江西省: [116.0046, 28.6633],
  山东省: [117.1582, 36.8701],
  河南省: [113.4668, 34.6234],
  湖北省: [114.3896, 30.6628],
  湖南省: [113.0823, 28.2568],
  广东省: [113.5107, 23.2196],
  广西壮族自治区: [108.479, 23.1152],
  海南省: [110.3893, 19.8516],
  重庆市: [107.7539, 30.1904],
  四川省: [103.9526, 30.7617],
  贵州省: [106.6992, 26.7682],
  云南省: [102.9199, 25.4663],
  西藏自治区: [91.1865, 30.1465],
  陕西省: [109.1162, 34.2004],
  甘肃省: [103.5901, 36.3043],
  青海省: [101.4038, 36.8207],
  宁夏回族自治区: [106.3586, 38.1775],
  新疆维吾尔自治区: [87.9236, 43.5883],
  台湾: [121.6, 24.9],
  澳门: [22.1, 113.33],
  香港: [114.15, 22.15],

  北京: [116.4551, 40.2539],
  天津: [117.4219, 39.4189],
  河北: [114.4995, 38.1006],
  山西: [112.3352, 37.9413],
  内蒙古: [111.4124, 40.4901],
  辽宁: [123.1238, 42.1216],
  吉林: [125.8154, 44.2584],
  黑龙江: [127.9688, 45.368],
  上海: [121.4648, 31.2891],
  江苏: [118.8062, 31.9208],
  浙江: [119.5313, 29.8773],
  安徽: [117.29, 32.0581],
  福建: [119.4543, 25.9222],
  江西: [116.0046, 28.6633],
  山东: [117.1582, 36.8701],
  河南: [113.4668, 34.6234],
  湖北: [114.3896, 30.6628],
  湖南: [113.0823, 28.2568],
  广东: [113.5107, 23.2196],
  广西: [108.479, 23.1152],
  海南: [110.3893, 19.8516],
  重庆: [107.7539, 30.1904],
  四川: [103.9526, 30.7617],
  贵州: [106.6992, 26.7682],
  云南: [102.9199, 25.4663],
  西藏: [91.1865, 30.1465],
  陕西: [109.1162, 34.2004],
  甘肃: [103.5901, 36.3043],
  青海: [101.4038, 36.8207],
  宁夏: [106.3586, 38.1775],
  新疆: [87.9236, 43.5883],

  合肥: [117.29, 32.0581],
  东莞: [113.8953, 22.901],
  东营: [118.7073, 37.5513],
  中山: [113.4229, 22.478],
  临汾: [111.4783, 36.1615],
  临沂: [118.3118, 35.2936],
  丹东: [124.541, 40.4242],
  丽水: [119.5642, 28.1854],
  乌鲁木齐: [87.9236, 43.5883],
  佛山: [112.8955, 23.1097],
  保定: [115.0488, 39.0948],
  兰州: [103.5901, 36.3043],
  包头: [110.3467, 41.4899],
  北海: [109.314, 21.6211],
  南京: [118.8062, 31.9208],
  南宁: [108.479, 23.1152],
  南昌: [116.0046, 28.6633],
  南通: [121.1023, 32.1625],
  厦门: [118.1689, 24.6478],
  台州: [121.1353, 28.6688],

  呼和浩特: [111.4124, 40.4901],
  咸阳: [108.4131, 34.8706],
  哈尔滨: [127.9688, 45.368],
  唐山: [118.4766, 39.6826],
  嘉兴: [120.9155, 30.6354],
  大同: [113.7854, 39.8035],
  大连: [122.2229, 39.4409],
  太原: [112.3352, 37.9413],
  威海: [121.9482, 37.1393],
  宁波: [121.5967, 29.6466],
  宝鸡: [107.1826, 34.3433],
  宿迁: [118.5535, 33.7775],
  常州: [119.4543, 31.5582],
  广州: [113.5107, 23.2196],
  廊坊: [116.521, 39.0509],
  延安: [109.1052, 36.4252],
  张家口: [115.1477, 40.8527],
  徐州: [117.5208, 34.3268],
  德州: [116.6858, 37.2107],
  惠州: [114.6204, 23.1647],
  成都: [103.9526, 30.7617],
  扬州: [119.4653, 32.8162],
  承德: [117.5757, 41.4075],
  拉萨: [91.1865, 30.1465],
  无锡: [120.3442, 31.5527],
  日照: [119.2786, 35.5023],
  昆明: [102.9199, 25.4663],
  杭州: [119.5313, 29.8773],
  枣庄: [117.323, 34.8926],
  柳州: [109.3799, 24.9774],
  株洲: [113.5327, 27.0319],
  武汉: [114.3896, 30.6628],
  汕头: [117.1692, 23.3405],
  江门: [112.6318, 22.1484],
  沈阳: [123.1238, 42.1216],
  沧州: [116.8286, 38.2104],
  河源: [114.917, 23.9722],
  泉州: [118.3228, 25.1147],
  泰安: [117.0264, 36.0516],
  泰州: [120.0586, 32.5525],
  济南: [117.1582, 36.8701],
  济宁: [116.8286, 35.3375],
  海口: [110.3893, 19.8516],
  淄博: [118.0371, 36.6064],
  淮安: [118.927, 33.4039],
  深圳: [114.5435, 22.5439],
  清远: [112.9175, 24.3292],
  温州: [120.498, 27.8119],
  渭南: [109.7864, 35.0299],
  湖州: [119.8608, 30.7782],
  湘潭: [112.5439, 27.7075],
  滨州: [117.8174, 37.4963],
  潍坊: [119.0918, 36.524],
  烟台: [120.7397, 37.5128],
  玉溪: [101.9312, 23.8898],
  珠海: [113.7305, 22.1155],
  盐城: [120.2234, 33.5577],
  盘锦: [121.9482, 41.0449],
  石家庄: [114.4995, 38.1006],
  福州: [119.4543, 25.9222],
  秦皇岛: [119.2126, 40.0232],
  绍兴: [120.564, 29.7565],
  聊城: [115.9167, 36.4032],
  肇庆: [112.1265, 23.5822],
  舟山: [122.2559, 30.2234],
  苏州: [120.6519, 31.3989],
  莱芜: [117.6526, 36.2714],
  菏泽: [115.6201, 35.2057],
  营口: [122.4316, 40.4297],
  葫芦岛: [120.1575, 40.578],
  衡水: [115.8838, 37.7161],
  衢州: [118.6853, 28.8666],
  西宁: [101.4038, 36.8207],
  西安: [109.1162, 34.2004],
  贵阳: [106.6992, 26.7682],
  连云港: [119.1248, 34.552],
  邢台: [114.8071, 37.2821],
  邯郸: [114.4775, 36.535],
  郑州: [113.4668, 34.6234],
  鄂尔多斯: [108.9734, 39.2487],

  金华: [120.0037, 29.1028],
  铜川: [109.0393, 35.1947],
  银川: [106.3586, 38.1775],
  镇江: [119.4763, 31.9702],
  长春: [125.8154, 44.2584],
  长沙: [113.0823, 28.2568],
  长治: [112.8625, 36.4746],
  阳泉: [113.4778, 38.0951],
  青岛: [120.4651, 36.3373],
  韶关: [113.7964, 24.7028]
};

```

# 驼峰转下划线
```javascript
const hyphenateRE = /\B([A-Z])/g
 const hyphenate = str=> {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
}
```

# 洗牌算法
```javascript
function shuffle(arr) {
    let shuffled = arr.concat(), rand;
    for (let i = shuffled.length; i--;) {
        rand = Math.floor(Math.random() * (i + 1));
        [shuffled[i],shuffled[rand]] = [shuffled[rand],shuffled[i]] 
    }
    return shuffled;
}
```

# 过滤html敏感符号
```javascript
function htmlEscape(text) {
  return text.replace(/[<>"&]/g, function(match, pos, originalText) {
    switch (match) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case '"':
        return "&quot;";
    }
  });
}
alert(htmlEscape('<p class="greeting">Hello world!</p>'));
```

# 判断浏览器UA
```javascript
// Browser environment sniffing
export const inBrowser = typeof window !== 'undefined'
export const inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform
export const weexPlatform = inWeex && WXEnvironment.platform.toLowerCase()
export const UA = inBrowser && window.navigator.userAgent.toLowerCase()
export const isIE = UA && /msie|trident/.test(UA)
export const isIE9 = UA && UA.indexOf('msie 9.0') > 0
export const isEdge = UA && UA.indexOf('edge/') > 0
export const isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android')
export const isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios')
export const isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge
export const isPhantomJS = UA && /phantomjs/.test(UA)
export const isFF = UA && UA.match(/firefox\/(\d+)/)
```

## 简体中文转繁体中文，并可区分港台繁体
> https://segmentfault.com/a/1190000020591236

```javascript
zh_CN_2_zh_HK_TW('我要做公共汽车去出差','zh-tw'); // zh-hk

function zh_CN_2_zh_HK_TW(str, type) {
    // 简体转繁体
    // zh :[hk,tw]
    //默认返回台湾繁体字
    var langMap = zhTraditional();
    for (var oldItem in zhTraditional) {
        var hasItem = str.indexOf(oldItem) > -1;
        if (hasItem) {
            var newStr = typeof langMap[oldItem] === 'string' ? langMap[oldItem] : langMap[oldItem][type === 'zh-tw' ? 1 : 0];
            var reg = new RegExp(oldItem, 'g');
            str = str.replace(reg, newStr);
        }
    }
    return str;
}


function zhTraditional(){
    // 这里才是重点，我费了几天时间，查找港台繁体字的区别，都整理这里了。如果你有更多的区别，评论区留下你的宝贵建议。
    return {
    "里面": [
        "裏面",
        "裡面"
    ],
    "软件": [
        "軟件",
        "軟體"
    ],
    "出租车": [
        "的士",
        "計程車"
    ],
    "公共汽车": [
        "巴士",
        "公車"
    ],
    "公交车": [
        "巴士",
        "公車"
    ],
    "摩托车": [
        "電單車",
        "機車"
    ],
    "摩托": [
        "電單車",
        "機車"
    ],
    "空调": [
        "冷氣機",
        "冷氣機"
    ],
    "计算器": [
        "電算器",
        "計數機"
    ],
    "钥匙": [
        "鎖匙",
        "鑰匙"
    ],
    "出差": [
        "公幹",
        "公幹"
    ],
    "游泳": [
        "游水",
        "游水"
    ],
    "烫发": [
        "電髮",
        "燙髮"
    ],
    "马铃薯": [
        "蕃薯",
        "蕃薯"
    ],
    "救护车": [
        "十字車",
        "救護車"
    ],
    "急救车": [
        "十字車",
        "救護車"
    ],
    "方便面": [
        "即食面",
        "速食面"
    ],
    "蜂蜜": [
        "蜜糖",
        "蜂蜜"
    ],
    "草莓": [
        "士多啤犁",
        "草莓"
    ],
    "水果": [
        "生果",
        "水果"
    ],
    "樱桃": [
        "車厘子",
        "櫻桃"
    ],
    "提示": [
        "貼士",
        "提示"
    ],
    "沙拉": [
        "沙律",
        "沙拉"
    ],
    "色拉": [
        "沙律",
        "沙拉"
    ],
    "话筒": [
        "咪高峰",
        "麥克風"
    ],
    "麦克风": [
        "咪高峰",
        "麥克風"
    ],
    "三明治": [
        "三文治",
        "三明治"
    ],
    "马达": [
        "摩打",
        "馬達"
    ],
    "巧克力": [
        "朱古力",
        "巧克力"
    ],
    "冰箱": [
        "雪櫃",
        "冰箱"
    ],
    "激光": [
        "鐳射",
        "雷射"
    ],
    "首席执行官": [
        "行政總監",
        "執行長"
    ],
    "首席运营官": [
        "營運總監",
        "營運長"
    ],
    "首席财务官": [
        "財務總監",
        "財務長"
    ],
    "信用证": [
        "信用證",
        "信用狀"
    ],
    "卡": [
        "咭",
        "卡"
    ],
    "瓶": [
        "樽",
        "瓶"
    ],
    "叹": [
        "歎",
        "嘆"
    ],
    "为": [
        "爲",
        "為"
    ],
    "着": [
        "着",
        "著"
    ],
    "妆": [
        "粧",
        "妝"
    ],
    "床": [
        "牀",
        "床"
    ],
    "里": [
        "裏",
        "裡"
    ],
    "线": [
        "綫",
        "線"
    ],
    "面": [
        "麪",
        "麵"
    ],
    "钩": [
        "鈎",
        "鉤"
    ],
    "群": [
        "羣",
        "群"
    ],
    "酝": [
        "醖",
        "醞"
    ],
    "卫": [
        "衞",
        "衛"
    ],
    "才": [
        "才",
        "纔"
    ],
    "峰": [
        "峯",
        "峰"
    ],
    "污": [
        "污",
        "汙"
    ],
    "爱": "愛",
    "碍": "礙",
    "袄": "襖",
    "肮": "骯",
    "罢": "罷",
    "坝": "壩",
    "摆": "擺",
    "办": "辦",
    "板": "闆",
    "帮": "幫",
    "宝": "寶",
    "报": "報",
    "贝": "貝",
    "备": "備",
    "笔": "筆",
    "币": "幣",
    "毕": "畢",
    "毙": "斃",
    "边": "邊",
    "变": "變",
    "标": "標",
    "表": "錶",
    "别": "彆",
    "宾": "賓",
    "卜": "蔔",
    "补": "補",
    "布": "佈",
    "参": "參",
    "惨": "慘",
    "蚕": "蠶",
    "灿": "燦",
    "仓": "倉",
    "层": "層",
    "产": "產",
    "搀": "攙",
    "谗": "讒",
    "馋": "饞",
    "缠": "纏",
    "忏": "懺",
    "尝": "嘗",
    "偿": "償",
    "厂": "廠",
    "长": "長",
    "车": "車",
    "彻": "徹",
    "陈": "陳",
    "尘": "塵",
    "衬": "襯",
    "唇": "脣",
    "称": "稱",
    "惩": "懲",
    "痴": "癡",
    "迟": "遲",
    "齿": "齒",
    "冲": "衝",
    "虫": "蟲",
    "丑": "醜",
    "筹": "籌",
    "处": "處",
    "触": "觸",
    "出": "齣",
    "础": "礎",
    "刍": "芻",
    "疮": "瘡",
    "辞": "辭",
    "从": "從",
    "聪": "聰",
    "丛": "叢",
    "窜": "竄",
    "达": "達",
    "呆": "獃",
    "带": "帶",
    "担": "擔",
    "胆": "膽",
    "单": "單",
    "当": "當",
    "档": "檔",
    "党": "黨",
    "导": "導",
    "灯": "燈",
    "邓": "鄧",
    "敌": "敵",
    "籴": "糴",
    "递": "遞",
    "淀": "澱",
    "点": "點",
    "电": "電",
    "垫": "墊",
    "冬": "鼕",
    "东": "東",
    "冻": "凍",
    "栋": "棟",
    "动": "動",
    "斗": "鬥",
    "独": "獨",
    "断": "斷",
    "对": "對",
    "队": "隊",
    "吨": "噸",
    "夺": "奪",
    "堕": "墮",
    "恶": "惡",
    "尔": "爾",
    "儿": "兒",
    "发": "發",
    "范": "範",
    "矾": "礬",
    "飞": "飛",
    "奋": "奮",
    "粪": "糞",
    "坟": "墳",
    "风": "風",
    "丰": "豐",
    "凤": "鳳",
    "妇": "婦",
    "复": "復",
    "麸": "麩",
    "肤": "膚",
    "盖": "蓋",
    "干": "幹",
    "赶": "趕",
    "个": "個",
    "巩": "鞏",
    "沟": "溝",
    "过": "過",
    "构": "構",
    "购": "購",
    "谷": "穀",
    "顾": "顧",
    "雇": "僱",
    "刮": "颳",
    "挂": "掛",
    "关": "關",
    "观": "觀",
    "冈": "岡",
    "广": "廣",
    "归": "歸",
    "龟": "龜",
    "柜": "櫃",
    "国": "國",
    "硅": "矽",
    "汉": "漢",
    "号": "號",
    "合": "閤",
    "轰": "轟",
    "哄": "閧",
    "后": "後",
    "胡": "鬍",
    "护": "護",
    "壶": "壺",
    "沪": "滬",
    "画": "畫",
    "划": "劃",
    "华": "華",
    "怀": "懷",
    "坏": "壞",
    "欢": "歡",
    "环": "環",
    "还": "還",
    "回": "迴",
    "会": "會",
    "秽": "穢",
    "汇": "匯",
    "伙": "夥",
    "获": "獲",
    "迹": "跡",
    "几": "幾",
    "机": "機",
    "击": "擊",
    "际": "際",
    "剂": "劑",
    "济": "濟",
    "挤": "擠",
    "积": "積",
    "饥": "飢",
    "鸡": "鷄",
    "极": "極",
    "继": "繼",
    "家": "傢",
    "价": "價",
    "夹": "夾",
    "艰": "艱",
    "荐": "薦",
    "戋": "戔",
    "坚": "堅",
    "歼": "殲",
    "监": "監",
    "见": "見",
    "茧": "繭",
    "舰": "艦",
    "鉴": "鑒",
    "拣": "揀",
    "硷": "礆",
    "姜": "薑",
    "将": "將",
    "奖": "獎",
    "浆": "漿",
    "桨": "槳",
    "酱": "醬",
    "讲": "講",
    "胶": "膠",
    "借": "藉",
    "阶": "階",
    "节": "節",
    "疖": "癤",
    "秸": "稭",
    "杰": "傑",
    "尽": "盡",
    "紧": "緊",
    "仅": "僅",
    "进": "進",
    "烬": "燼",
    "惊": "驚",
    "竞": "競",
    "旧": "舊",
    "举": "舉",
    "剧": "劇",
    "据": "據",
    "巨": "鉅",
    "惧": "懼",
    "卷": "捲",
    "觉": "覺",
    "开": "開",
    "克": "剋",
    "壳": "殼",
    "垦": "墾",
    "恳": "懇",
    "夸": "誇",
    "块": "塊",
    "矿": "礦",
    "亏": "虧",
    "昆": "崑",
    "捆": "綑",
    "困": "睏",
    "扩": "擴",
    "腊": "臘",
    "蜡": "蠟",
    "来": "來",
    "兰": "蘭",
    "拦": "攔",
    "栏": "欄",
    "烂": "爛",
    "劳": "勞",
    "痨": "癆",
    "乐": "樂",
    "类": "類",
    "累": "纍",
    "垒": "壘",
    "泪": "淚",
    "厘": "釐",
    "礼": "禮",
    "厉": "厲",
    "励": "勵",
    "离": "離",
    "历": "暦",
    "隶": "隸",
    "俩": "倆",
    "帘": "簾",
    "联": "聯",
    "恋": "戀",
    "怜": "憐",
    "炼": "煉",
    "练": "練",
    "粮": "糧",
    "两": "兩",
    "辆": "輛",
    "了": "瞭",
    "疗": "療",
    "辽": "遼",
    "猎": "獵",
    "临": "臨",
    "邻": "鄰",
    "灵": "靈",
    "龄": "齡",
    "岭": "嶺",
    "刘": "劉",
    "浏": "瀏",
    "龙": "龍",
    "楼": "樓",
    "娄": "婁",
    "录": "錄",
    "陆": "陸",
    "虏": "虜",
    "卤": "鹵",
    "卢": "盧",
    "庐": "廬",
    "泸": "瀘",
    "芦": "蘆",
    "炉": "爐",
    "乱": "亂",
    "仑": "侖",
    "罗": "羅",
    "屡": "屢",
    "虑": "慮",
    "滤": "濾",
    "驴": "驢",
    "麻": "蔴",
    "马": "馬",
    "买": "買",
    "卖": "賣",
    "迈": "邁",
    "麦": "麥",
    "脉": "脈",
    "猫": "貓",
    "蛮": "蠻",
    "门": "門",
    "黾": "黽",
    "么": "麼",
    "霉": "徾",
    "蒙": "濛",
    "梦": "夢",
    "弥": "彌",
    "庙": "廟",
    "灭": "滅",
    "蔑": "衊",
    "亩": "畝",
    "难": "難",
    "鸟": "鳥",
    "恼": "惱",
    "脑": "腦",
    "拟": "擬",
    "酿": "釀",
    "聂": "聶",
    "镊": "鑷",
    "疟": "瘧",
    "宁": "寧",
    "农": "農",
    "欧": "歐",
    "盘": "盤",
    "辟": "闢",
    "苹": "蘋",
    "凭": "憑",
    "朴": "樸",
    "仆": "僕",
    "扑": "撲",
    "栖": "棲",
    "齐": "齊",
    "气": "氣",
    "弃": "棄",
    "启": "啟",
    "岂": "豈",
    "千": "韆",
    "迁": "遷",
    "佥": "僉",
    "签": "簽",
    "牵": "牽",
    "纤": "縴",
    "蔷": "薔",
    "墙": "墻",
    "枪": "槍",
    "乔": "喬",
    "侨": "僑",
    "桥": "橋",
    "窍": "竅",
    "窃": "竊",
    "亲": "親",
    "寝": "寢",
    "庆": "慶",
    "穷": "窮",
    "琼": "瓊",
    "秋": "鞦",
    "区": "區",
    "曲": "麯",
    "趋": "趨",
    "权": "權",
    "劝": "勸",
    "确": "確",
    "让": "讓",
    "扰": "擾",
    "热": "熱",
    "认": "認",
    "荣": "榮",
    "洒": "灑",
    "伞": "傘",
    "丧": "喪",
    "扫": "掃",
    "啬": "嗇",
    "涩": "澀",
    "杀": "殺",
    "晒": "曬",
    "伤": "傷",
    "舍": "捨",
    "摄": "攝",
    "沈": "瀋",
    "审": "審",
    "渗": "滲",
    "声": "聲",
    "升": "陞",
    "胜": "勝",
    "圣": "聖",
    "绳": "繩",
    "湿": "濕",
    "适": "適",
    "时": "時",
    "实": "實",
    "势": "勢",
    "师": "師",
    "兽": "獸",
    "属": "屬",
    "数": "數",
    "术": "術",
    "树": "樹",
    "书": "書",
    "帅": "帥",
    "双": "雙",
    "松": "鬆",
    "苏": "蘇",
    "肃": "肅",
    "虽": "雖",
    "随": "隨",
    "岁": "歲",
    "孙": "孫",
    "笋": "筍",
    "它": "牠",
    "态": "態",
    "台": "臺",
    "檯": "颱",
    "摊": "攤",
    "滩": "灘",
    "瘫": "癱",
    "坛": "壇",
    "汤": "湯",
    "誊": "謄",
    "体": "體",
    "条": "條",
    "椭": "橢",
    "粜": "糶",
    "铁": "鐵",
    "听": "聽",
    "厅": "廳",
    "头": "頭",
    "图": "圖",
    "涂": "塗",
    "团": "團",
    "袜": "襪",
    "洼": "漥",
    "万": "萬",
    "弯": "彎",
    "网": "網",
    "伪": "偽",
    "韦": "韋",
    "稳": "穩",
    "乌": "烏",
    "务": "務",
    "无": "無",
    "雾": "霧",
    "牺": "犧",
    "席": "蓆",
    "系": "係",
    "戏": "戲",
    "习": "習",
    "吓": "嚇",
    "虾": "蝦",
    "绣": "繡",
    "锈": "銹",
    "献": "獻",
    "咸": "醎",
    "显": "顯",
    "宪": "憲",
    "县": "縣",
    "向": "嚮",
    "响": "響",
    "乡": "鄉",
    "协": "協",
    "写": "寫",
    "胁": "脅",
    "泻": "瀉",
    "亵": "褻",
    "衅": "釁",
    "兴": "興",
    "须": "鬚",
    "选": "選",
    "旋": "鏇",
    "悬": "懸",
    "学": "學",
    "寻": "尋",
    "逊": "遜",
    "凶": "兇",
    "压": "壓",
    "亚": "亞",
    "哑": "啞",
    "艳": "艷",
    "严": "嚴",
    "岩": "巖",
    "盐": "鹽",
    "厌": "厭",
    "养": "養",
    "痒": "癢",
    "样": "樣",
    "阳": "陽",
    "尧": "堯",
    "钥": "鑰",
    "药": "藥",
    "页": "頁",
    "叶": "葉",
    "爷": "爺",
    "业": "業",
    "医": "醫",
    "异": "異",
    "义": "義",
    "仪": "儀",
    "艺": "藝",
    "亿": "億",
    "忆": "憶",
    "隐": "隱",
    "阴": "陰",
    "蝇": "蠅",
    "应": "應",
    "营": "營",
    "拥": "擁",
    "佣": "傭",
    "踊": "踴",
    "涌": "湧",
    "痈": "癰",
    "优": "優",
    "犹": "猶",
    "邮": "郵",
    "忧": "憂",
    "余": "餘",
    "鱼": "魚",
    "御": "禦",
    "吁": "籲",
    "郁": "鬱",
    "与": "與",
    "誉": "譽",
    "屿": "嶼",
    "渊": "淵",
    "远": "遠",
    "园": "園",
    "愿": "願",
    "跃": "躍",
    "岳": "嶽",
    "云": "雲",
    "运": "運",
    "韵": "韻",
    "札": "剳",
    "扎": "紥",
    "杂": "雜",
    "灾": "災",
    "赃": "贓",
    "灶": "竈",
    "凿": "鑿",
    "枣": "棗",
    "斋": "齋",
    "战": "戰",
    "占": "佔",
    "毡": "氈",
    "赵": "趙",
    "这": "這",
    "折": "摺",
    "征": "徵",
    "症": "癥",
    "证": "證",
    "郑": "鄭",
    "只": "祗",
    "帜": "幟",
    "职": "職",
    "致": "緻",
    "制": "製",
    "执": "執",
    "滞": "滯",
    "质": "質",
    "种": "種",
    "众": "眾",
    "钟": "鐘",
    "肿": "腫",
    "周": "週",
    "昼": "晝",
    "朱": "誅",
    "筑": "築",
    "烛": "燭",
    "注": "註",
    "专": "專",
    "庄": "莊",
    "壮": "壯",
    "装": "裝",
    "状": "狀",
    "桩": "樁",
    "准": "準",
    "浊": "濁",
    "总": "總",
    "纵": "縱",
    "钻": "鑚"
};
}
```


# 判断是否是PC
```javascript
/**
 * 判断是否是PC环境
 * @return {Boolean} true 就是PC  false 不是PC
 * @description https://www.cnblogs.com/s313139232/p/9447069.html
 */
export const isPC = () => {
  const userAgentInfo = navigator.userAgent;
  const Agents = [
    "Android",
    "iPhone",
    "SymbianOS",
    "Windows Phone",
    "iPad",
    "iPod"
  ];
  let flag = true;
  for (let i = 0, l = Agents.length; i < l; i++) {
    if (userAgentInfo.indexOf(Agents[i]) > 0) {
      flag = false;
      break;
    }
  }
  return flag;
};
```

# 长按逻辑的思路
- touchstart 创建一个延迟函数
- touchmove 清除这个延迟
- touchend 清除延迟


# 音频能量分级
```javascript
// x /= y 等同于 x = x/y
var _getVolume = function(data){
    //音频能量分级
    var volumeEnergy = [328,421,541,695,893,1147,1473,1892,2430,3121,4007,5145,6607,8484,10893,13987,17959,23060,29609,38018,48814,62676,80476,103329,132673,170349,218724,280837,360589,462988,594466,763280,980034,1258341,1615680,2074495,2663603,3420004,4391204];
    var getLevelByEnergy = function(energy){
        var level = 40;
        volumeEnergy.every(function(value,index){
            if(energy < value){
                level = index;
                return false;//跳出循环
            }
            return true;
        });
        return level;
    };
    var calEnergy = function(data){
        if(data == null || data.byteLength <= 2){
            return 0;
        }
        // 采样平均值
        var avg = 0;
        var i;
        for(i=0;i<data.length;i++){
            avg += data[i];
        }
        avg /= data.length;
        var energy = 0;
        for(i=0;i<data.length;i++){
            energy += parseInt(Math.pow(data[i]-avg,2))>>9;
        }
        energy /= data.length;
        return parseInt(energy);
    };
    return getLevelByEnergy(calEnergy(data));
};
```