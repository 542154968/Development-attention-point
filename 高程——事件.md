# 简介
- JS和HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用`侦听器（或处理程序）`来预定事件，以便事件发生时执行相应的代码，这种在传统工程中被称为观察员模式的模型，支持页面的行为（JS）与页面（CSSHTML）之间的松散耦合
- IE8是最后一个仍然使用其专有事件系统的主要浏览器

# 事件流
- 事件流描述的是从而绵中接收事件的顺序，但是IE与Netscape开发团队提出的是差不多完全相反的事件流概念，IE事件流是**冒泡**，而NC事件流是**捕获**

## **冒泡**
- IE的事件流叫做事件冒泡，即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）
- IE5.5及更早版本冒泡会跳过html元素（从body直接跳到docuemnt）IE9+别的浏览器则将事件一直冒泡到window对象

## **捕获**
- NC定义，事件捕获的思想是不太具体的节点应该更糟接收到事件，而最具体的节点英爱最后接收到事件，事件捕获的用意在于在事件打到预定目标之前捕获它
- IE9+ 部分老浏览器从window开始 规范要求从docuemnt对象开始

## DOM事件流
- `dom2级事件`规定的事件流包括三个阶段： 事件捕获阶段、处于目标阶段和事件冒泡阶段
- 首先发生的是事件捕获，为截获事件提供了机会
- 然后是实际的目标接收到事件
- 最后是冒泡阶段，可以再找个阶段对事件做出响应

- 在DOM事件流中，实际的目标（div元素）在捕获阶段不会接收到事件，这意味着在捕获阶段，事件从document到html再到body后就停止了
- 下一个阶段是处于目标阶段，于是事件在div上发生，并在事件处理中被看成冒泡阶段的一部分，然后，冒泡阶段发生，事件有传播回文档
- 即时DOM2级事件规范名曲要求捕获阶段不会涉及事件目标，但IE9等更高版本浏览器都会在捕获阶段触发事件对象上的事件
- IE8及更早版本不支持事件流

## 事件处理程序
- 事件就是用户或浏览器自身执行的某种操作。而响应某个事件的函数就叫做事件处理程序或事件侦听器。事件处理程序的名字以on开头

**HTML事件处理程序**
- 某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。这个特性的值应该是能够执行的JS代码
- 不能使用未经转移的HTML语法字符串 例如& "" < > 
```html
<input onclick="alert(&quot;clicked&quot;)">
```
- 也可以这样
```javascript
<script type="text/javascript">
  function showMessage(){
    alert("Hellow World!")
  }
</script>
```
- 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码
- 这样指定事件处理程序具有一些独到之处，首先，这样会创建一个封装这元素属性值的函数。这个函数中有一个局部变量`event`也就是事件对象。
```html
<input type="button" value="Click me" onclick = "alert(event.type)" >
function(){ 
  with(document){ 
    with(this.form){ 
      with(this){ 
      //元素属性值
      } 
    }
  } 
} 
```
- 在HTML中之指定事件处理程序由两个缺点。
- 1. 时差问题。因为用户可能在HTML元素一出现在页面上就触发相应的事件，当当时的事件处理程序可能尚不具备执行条件，因此 很多的HTML事件处理程序都会被封装在一个try-catch块中
  2. 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。不同JS引擎遵循的标识符解析规则略有差异，很可能会在访问非限定对象成员时出错
- 这样抒写过于紧密耦合，如果要更换事件处理程序就要更改两个地方HTML代码和JS代码。这正是开发人员掘弃HTML事件处理程序转而使用JS指定事件处理程序的原因所在。  

## DOM0级事件处理程序
- 通过JS指定事件处理程序的传统方式，就是讲一个函数赋值给一个事件处理程序属性。这个中为事件处理程序复制的方法是在第四代Web浏览器中出现的，而且至今冉根为所有现代浏览器所支持。原因1是简单，而是具有跨浏览器的又是。
- 要使用JS指定事件处理程序，首先要取得一个要操作的UI想的引用
- 每个元素都有自己的事件处理程序属性，这些属性通常全部小写。将这种属性的值设置为一个函数，就可以指定事件处理程序
- 这些代码运行以前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就可能在一段时间内怎么点击都没有反应
- 使用DOM0级方法指定的事件处理程序被认为是元素的方法，因此这时候的事件处理程序是在元素的作用域中运行，换句话说，程序中的this引用当前元素；
```javascript
var btn = document.getElementById("myBtn");
btn.onclick = function(){
  alert(this.id)
}
```
- 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理
- 也可以删除通过DOM0级的方法指定的事件处理程序
```javascript
btn.onclick = null
```
- 如果你是HTML指定事件处理程序，那么onclick属性的值就是一个包含着在同名HTML特性中指定的代码的函数。而将响应的属性设置为null也可以删除以这种方式指定的事件处理程序

## DOM2级事件处理程序
- DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作 `addEventListener（）`和`removeEventListener()`
- 所有的DOM节点中都包含这两个方法，并且他们都接受3个参数： 要处理的事件名、 作为事件处理程序的函数 和 一个布尔值，最后的布尔值参数如果是true，表示在捕获阶段调用事件处理程序，如果是false表示在冒泡阶段处理程序
```javascript
var btn = docuemnt.getElementById("myBtn");
btn.addEventListener( "click", function(){
  alert(this.id)
}, false )
```
- 使用DOM2级的方法可以添加多个事件处理程序
```javascript
var btn = docuemnt.getElementById("myBtn");
btn.addEventListener( "click", function(){
  alert(this.id)
}, false )
btn.addEventListener("click", function(){
  alert("hello")
}, false)
```
- 通过 `addEventListener`添加的事件只能通过`removeEventListener`来移除
- 移除时传入的参数与添加处理程序时使用的参数相同。这也意味着通过`addEventListener`添加的**匿名函数**无法移除
```javascript
var btn = docuemnt.getElementById("myBtn");
btn.addEventListener("click", function(){
  alert(this.id)
}, false)
// 没有用
btn.removeEventListener("click", function(){
  alert(this.id)
}, false)
```
- 这个例子则可以
```javascript
var btn = docuemnt.getElementById("myBtn");
var handler = function(){
  alert(this.id)
}
btn.addEventListener( "click", handler, false );
btn.removeEventListener( "click", handler, false );
```
- 大部分情况下都是将事件处理程序添加到事件流的冒泡阶段，这样可以大限度的兼容各种浏览器。
- 最好只在需要在事件到达目标之前截获它的时候将事件处理程序天基调捕获阶段，不建议添加到捕获阶段
- IE9+

## IE事件处理程序
- IE实现了与DOM中类似的两个方法： `attachEvent()`和`detechEvent()`。
- 这两个方法接受相同的两个参数： 事件处理程序名称与时间处理程序的函数。
- 由于IE8-只支持事件冒泡，所以通过`attachEvent`添加的事件处理程序都会被添加到冒泡阶段
```javascript
var btn = doucment.getElementById("myBtn");
btn.attachEvent("onclick", function(){
  alert("clicked")
})
```
- 注意第一个参数是`onclick`而非DOM的`addEventListener`方法中的click
- 在IE中使用`attachEvent()`与使用DOM0级方法的主要区别在于事件处理程序的作用域。
- 在使用DOM0级的方法的情况下，事件处理程序会在其所属元素的作用域内运行。
- 在使用`attachEvent()`方法的情况下，**事件处理程序会在全局作用域中运行**，因此this等于window
```javascript
var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(){
  alert(this === window) // true
})
```
- attachEvent方法也可以用来为一个元素添加多个事件处理程序， 与DOM方法不同的是，这些事件处理程序不是以添加他们的顺序执行，而是以相反的顺序触发。
- 使用`attachEvent`添加的事件可以通过`detachEvent`来移除，条件是必须提供相同的参数，所以**匿名函数**不能被移除。不过，只要能够将对相同函数的引用传给`detachEvent`就可以移除相应的事件处理程序
```javascript
var btn = document.getElementById("myBtn");
var handler = function(){
  alert("Clicked")
}
btn.attachEvent("onclick", hanlder);
btn.detachEvent("onclick", hanlder)
```

## 跨浏览器的事件处理程序
- 要保证处理事件的代码能再大多数浏览器下一致的运行，只需要关注冒泡阶段。

**addHandler()**
- 第一个要创建的方法是addHandler, 它的职责是视情况分别使用DOM0级方法、DOM2级方法或IE方法来添加事件。这个方法属于一个名叫`EventUtil`的对象。
- addHandler方法接受三个参数： 要操作的元素、事件名称和事件处理程序函数。
```javascript
var EventUtil = {
  addHandler: function(element, type, handler){
    if( element.addEventListener ){
      element.addEventListener(type, handler, false)
    } else if ( element.attachEvent ){
      element.attachEvent( "on" + type, handler )
    } else {
      element[ "on" + type ] = handler
    }
  },
  removeHandler: function(element, type, handler){
    if( element.removeEventListener ){
      element.removeEventListener( type, handler, false )
    } else if( element.detachEvent ){
      element.detachEvent( "on" + type, handler )
    } else {
      element["on" + type] = null;
    }
  }
}
```
- 并没有考虑到所有的浏览器问题， 比如IE中的作用域问题，不过，使用它们移除和添加事件处理程序还是足够的
- DOM0级对每个事件只支持一个事件处理程序。

## 事件对象 —— event
- 在触发DOM上的某个事件时，会产生一个事件对象Event，这个对象中包含着所有与事件有关的信息

### DOM中的事件对象
- 兼容DOM的浏览器会将一个`event`独享传入到事件处理程序中，无论指定事件处理程序时使用什么方法（DOM0 DOM2），都会传入event对象
```javascript
var btn = doucment.getElementById("myBtn");
btn.onclick = function(event){
  alert(event.type)
}
btn.addEventListener("click", function(event){
  alert(event.type)
}, false)
```
