# 面向对象
> 其实有时间可以看向面向对象的语言 比如JAVA 推荐 `《First Head Java》`，有可能的话还是希望你先学习的是强类型的语言。

**简介**
- 面向对象的语言有一个标志，那就是他们都有类的概念（es6也有类了奥 不过是语法糖），而通过类可以创建任意多个具有相同属性和方法的对象。
- 可惜的是ECMAScript中没有类的概念，因此它的对象也与基于累的语言中的对象有所不同。
- `ECMA-262`把对象定义为 `无序属性的集合，其属性可以包含基本值、对象或者函数。`严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。
- 正因为这样，我们可以把`ECMAScript`的对象想象成散列表。
- 无非就是一组名值对，其中值可以是数据或函数。
- 每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员定义的类型。

## 理解对象
- 创建自定义对象的最简单方式就是创建一个`Object`的实例，然后再为它添加属性和方法。
```javascript
    var person = new Person();
    person.name = 'Nicholas';
    person.age = 29;
    person.job = "Software Engineer";
    
    person.sayName = function(){
        alert( this.name )
    }
```
- 后来，对象字面量成为创建对象的首选模式
```javascript
    var person = {
        name: 'Nicholas',
        age: 29,
        job: "Software Engineer",
        sayName: function(){
            alert( this.name )
        }
    }
```

## 属性类型
- `ECMA-262第5版`在定义只有内部采用的特性（attribute）时，描述了属性（property）的各种特征。
- 定义这些特性是为了实现JS引擎用的，因此在JS中不能直接访问他们。
- 为了表示特性是内部属性值，该规范把他们放在了两对儿方括号中， 例如`[[Enumerable]]`。

**数据属性**
> 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。

- [[Configurable]]: 表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，他们的这个特性默认值是true。
- [[Enumerable]]: 表示能否通过`for-in`循环返回属性。像前面那样直接在对象上定义的属性，他们的这个特性默认值是true。
- [[Writable]]: 表示能否修改属性的值。向前面例子中那样直接在对象上定义的属性，他们的这个特性默认是是true。
- [[Value]]: 包含这个属性的数据值。读取属性值的时候，从这个位置读。写入属性值的时候，把新值保存在这个位置。这个特性的默认值是`undefined`。
```javascript
    var person = {
        name: 'Nicholas'
    };
    // 它的[[Configurable]]、 [[Enumerable]]、 [[Writable]] 特性都被设置为true， 而 [[Value]] 被设置成了指定的值。
```

**Object.defineProperty()**
- 要修改如上属性默认的特性的方法。
- 这个方法接收三个参数： 属性所在的对象、属性的名字和一个描述符对象。
- 描述符（`descriptor`）对象的属性必须是： configurable、 enumerable、 writable和value。设置其中的一或多个值，可以修改对应的特性值。
```javascript
    var person = {};
    Object.defineProperty( person, 'name', {
        writable: false,
        value: 'Nicholas'
    });
    // 在费严格模式下，赋值操作将被忽略； 严格模式下，赋值操作将会抛出错误。
    person.name = 'Greg';
    alert( person.name ); // Nicholas
```
- 把`configurable`设置成false，表示不能从对象中删除属性。如果对这个属性调用delete，在诶严格模式下什么也不会发生，而再严格模式下会导致错误。而且，一旦把属性定义为不可配置的就不能再把它变回可配置了。此时，再调用Obejct.defineProperty()方法修改除writable之外的特性，都会导致错误。
- 在调用`Object.defineProperty()`方法时，如果不指定，`configurable`、`enumerable`和`writable`特性的默认值都是false。

**访问器属性**
- 访问器属性不包含数据值。
- 他们包含一对儿`getter`和`setter`函数（这两个函数都不是必须的）。
- 在读取访问器属性时，会调用`getter`函数，这个函数负责返回有效的值。
- 在写入访问器属性时，会调用`setter`函数并传入新值，这个函数负责决定如何处理数据。

**访问器的4个属性**
- [[Configurable]]: 表示能否通过`delete`删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。
- [[Enumerable]]: 能否通过`for-in`循环返回属性。对于直接在对象上定义的属性，这个特性的默认值是true。
- [[Get]]: 在读取属性时调用的函数， 默认值为`undefined`
- [[Set]]: 在写入属性时调用的函数， 默认值为`undefined`
- 访问器属性不能直接定义，必须使用**Object.defineProperty()**来定义。

```javascript
var book = {
    _year: 2004,
    edition: 1
};
Object.defineProperty( book, 'year', {
    get: function(){
        return this._year
    },
    set: function(){
        if( newValue > 2004 ){
            this._year = newValue;
            this.edition += newValue - 2004;
        }
    }
});
book.year = 2005;
console.log( book.edition ) // 2
```

- 不一定非要同时指定`getter`和`setter`。只指定`getter`意味着属性时不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了`getter`函数的属性会抛出错误。
- 只指定`setter`函数的属性也不能读，否则在非严格模式下会返回`undefined`，严格模式下会抛出错误。

**Object.defineProperty()的向下兼容**
- 支持`ECMAScript5`的这个方法的浏览器有IE9+(IE8只是部分实现)、Firefox 4+、 Opera 12+、 Chrome。
- 在这个方法之前要创建访问器属性，一般使用两个非标准方法： `__defineGetter__()`和`__defineSetter__()`。这两个方法最初是由`Firefox`引入的，后来`Safari 3`、`Chrome 1`和`Opera 9.5`也给出了相同的实现。
```javascript
// 重现上述方法
var book = {
    _year: 2004,
    edition: 1
};
// 定义访问器的旧有方法
book.__defineGetter__( 'year', function(){
    return this._year
} );
book.__defineSetter__( 'year', function(){
    if( newValue > 2004 ){
        this._year = newValue;
        this.edition += newValue - 2004;
    }
} );
book.year = 2005;
alert( book.edition ); // 12
```

