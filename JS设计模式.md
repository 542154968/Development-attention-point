# Javascript 设计模式

## 单例模式

### 定义

1. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 惰性单例

#### 定义

1. 惰性单例指的是在需要的时候才创建对象实例。

#### 栗子

```js
if (!instance) {
  instance = new Fun();
}
return instance;
```

### 业务场景

1. 全局的`Drawer`或者`Modal`组件

## 策略模式

### 定义

1. 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。
2. 定义一系列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些
   策略对象中间的某一个进行计算。

### 业务场景

1. 比如有个 key 的列表对应不同的逻辑，我们可以把 key 和对应的逻辑封装成一个字典

```js
const key2Fn = {
  1(money) {
    return money * 1;
  },
  2(money) {
    return money * 2;
  },
  3(money) {
    return money * 3;
  },
};

function getItemMoney(level, baseMoney) {
  return key2Fn(level, baseMoney);
}

console.log(getItemMoney(2, 20000));
```

## 代理模式

### 定义

1. 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
2. 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。

### 保护代理

#### 定义

1. 代理 B 可以帮助 A 过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理 B 处被拒绝掉。这种代理叫作保护代理。
2. 保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式

### 虚拟代理

#### 定义

1. 假设现实中的花价格不菲，导致在程序世界里，new Flower 也是一个代价昂贵的操作，那么我们可以把 new Flower 的操作交给代理 B 去执行，代理 B 会选择在 A 心情好时再执行 new Flower，这是代理模式的另一种形式，叫作虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。

#### 业务场景

1. 图片加载过慢的时候展示一个默认图的业务场景

```js
// 假设图片很大，没有默认图片的时候，显示很久的留白，不好看，我们可以搞个默认图放在上面。
// 那为什么用虚拟代理去实现呢， 先回顾下虚拟代理的定义 虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。
// 在这种业务场景中，图片的加载过程很慢，可以理解为一个开销很大的过程，由于单一职责性，所以我们把创建图片的过程抽离出来

// 职责被定义为“引起变化的原因”。这段代码中的 MyImage 对象除了负责给 img 节点设置 src外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。

// 创建图片
const myImage = (function () {
  const imgNode = document.createElement("img");
  document.body.appendChild(imgNode);
  return {
    setSrc: function (src) {
      imgNode.src = src;
    },
  };
})();

// 虚拟代理设置默认图
const proxyImage = (function () {
  const img = new Image();
  img.onload = function () {
    myImage.setSrc(this.src);
  };
  return {
    setSrc: function (src) {
      // 1. myimage是个立即执行函数 会先创建好img然后添加到body上
      // 2. 调用setSrc设置默认图片 然后默认图片开始加载 它应该很快就load完成了
      // 3. 然后设置开始加载真实的图片 当真实的图片加载完成之后 替换imgNode的src 就显示真实的图片了
      myImage.setSrc("默认图片");
      img.src = src;
    },
  };
})();

proxyImage.setSrc("真实图片");
```

## 策略模式

### 定义

1. 策略模式指的是定义一系列的算法，把它们一个个封装起来。将不变的部分和变化的部分隔开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将算法的使用与算法的实现分离开来。
2. 一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用。
